<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bayesian Optimization Model Visualization</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        margin: 0;
        padding: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .container {
        width: 100%;
        max-width: 1200px;
        margin: 20px;
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
        backdrop-filter: blur(4px);
        border: 1px solid rgba(255, 255, 255, 0.18);
      }

      header {
        text-align: center;
        margin-bottom: 30px;
        color: #1a365d;
      }

      h1 {
        margin: 0;
        font-size: 2.2rem;
        background: linear-gradient(45deg, #1a365d, #2563eb);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .model-formula {
        font-size: 1.3rem;
        background-color: #f8fafc;
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
        overflow-x: auto;
        border-left: 4px solid #3b82f6;
      }

      .model-description {
        margin-bottom: 20px;
        line-height: 1.6;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
        justify-content: space-between;
      }

      .control-group {
        flex: 1;
        min-width: 250px;
        background-color: #f8fafc;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .control-group h3 {
        margin-top: 0;
        color: #1e40af;
      }

      .slider-container {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .slider-with-value {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      input[type="range"] {
        flex: 1;
        height: 6px;
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        background: #ddd;
        outline: none;
        border-radius: 5px;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #3b82f6;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        background: #1e40af;
        box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.1);
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #3b82f6;
        cursor: pointer;
        border: none;
        transition: all 0.3s ease;
      }

      input[type="range"]::-moz-range-thumb:hover {
        background: #1e40af;
        box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.1);
      }

      .value-display {
        width: 50px;
        text-align: center;
        font-weight: bold;
        color: #1e40af;
      }

      button {
        background-color: #3b82f6;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #1e40af;
      }

      .visualization {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }

      .plot-container {
        flex: 1;
        min-width: 300px;
        height: 400px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        background: white;
        position: relative;
      }

      .plot-title {
        text-align: center;
        font-weight: 600;
        margin-top: 5px;
        color: #1a365d;
      }

      .tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 100;
        display: none;
      }

      .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 5px solid rgba(59, 130, 246, 0.3);
        border-radius: 50%;
        border-top-color: #3b82f6;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .info-panel {
        background-color: #f0f9ff;
        border-left: 4px solid #38bdf8;
        padding: 15px;
        margin: 20px 0;
        border-radius: 0 8px 8px 0;
      }

      .info-panel h3 {
        margin-top: 0;
        color: #0369a1;
      }

      .canvas-container {
        position: relative;
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
      }

      .color-scale {
        display: flex;
        flex-direction: column;
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 200px;
        border-radius: 4px;
        overflow: hidden;
      }

      .color-gradient {
        flex: 1;
        background: linear-gradient(
          to top,
          hsl(240, 100%, 50%),
          hsl(180, 100%, 50%),
          hsl(120, 100%, 50%),
          hsl(60, 100%, 50%),
          hsl(0, 100%, 50%)
        );
      }

      .scale-labels {
        position: absolute;
        right: 25px;
        top: 50%;
        transform: translateY(-50%);
        height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 12px;
      }

      .scale-label {
        margin-right: 5px;
        text-align: right;
      }

      @media (max-width: 768px) {
        .container {
          margin: 10px;
          padding: 15px;
        }

        h1 {
          font-size: 1.8rem;
        }

        .model-formula {
          font-size: 1rem;
        }

        .plot-container {
          height: 300px;
        }
      }

      .tab-container {
        margin-bottom: 20px;
      }

      .tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
      }

      .tab {
        padding: 10px 15px;
        border-radius: 8px 8px 0 0;
        background-color: #e2e8f0;
        cursor: pointer;
        border: 1px solid #cbd5e1;
        border-bottom: none;
      }

      .tab.active {
        background-color: #3b82f6;
        color: white;
        font-weight: bold;
      }

      .tab-content {
        display: none;
        padding: 20px;
        background-color: #f8fafc;
        border-radius: 0 8px 8px 8px;
        border: 1px solid #cbd5e1;
      }

      .tab-content.active {
        display: block;
      }

      .realization-point {
        position: absolute;
        width: 8px;
        height: 8px;
        background-color: rgba(220, 38, 38, 0.7);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        transition: transform 0.3s ease;
      }

      @keyframes pulse {
        0% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(2);
          opacity: 0.8;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
      }

      .sample-controls {
        margin-top: 20px;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .sample-count {
        width: 60px;
      }

      #probability-plot {
        height: 150px;
        margin-top: 20px;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Bayesian Optimization Model Visualization</h1>
        <div class="model-formula">
          f(x) ~ N(x<sub>1</sub><sup>2</sup> - 2x<sub>1</sub>x<sub>2</sub> +
          cos(x<sub>2</sub>), cos(x<sub>1</sub><sup>2</sup> + x<sub>2</sub
          ><sup>2</sup>))
        </div>
      </header>

      <div class="model-description">
        <p>
          This interactive visualization allows you to explore the Bayesian
          optimization model above where:
        </p>
        <ul>
          <li>
            The mean function is
            <strong
              >x<sub>1</sub><sup>2</sup> - 2x<sub>1</sub>x<sub>2</sub> +
              cos(x<sub>2</sub>)</strong
            >
          </li>
          <li>
            The variance function is
            <strong
              >cos(x<sub>1</sub><sup>2</sup> + x<sub>2</sub
              ><sup>2</sup>)</strong
            >
          </li>
        </ul>
      </div>

      <div class="tab-container">
        <div class="tabs">
          <div class="tab active" data-tab="visualization">Visualization</div>
          <div class="tab" data-tab="about">About Bayesian Optimization</div>
        </div>

        <div class="tab-content active" data-tab-content="visualization">
          <div class="controls">
            <div class="control-group">
              <h3>Domain Settings</h3>
              <div class="slider-container">
                <label for="x1-min">x<sub>1</sub> minimum:</label>
                <div class="slider-with-value">
                  <input
                    type="range"
                    id="x1-min"
                    min="-5"
                    max="0"
                    step="0.1"
                    value="-3"
                  />
                  <span class="value-display" id="x1-min-value">-3</span>
                </div>
              </div>
              <div class="slider-container">
                <label for="x1-max">x<sub>1</sub> maximum:</label>
                <div class="slider-with-value">
                  <input
                    type="range"
                    id="x1-max"
                    min="0"
                    max="5"
                    step="0.1"
                    value="3"
                  />
                  <span class="value-display" id="x1-max-value">3</span>
                </div>
              </div>
              <div class="slider-container">
                <label for="x2-min">x<sub>2</sub> minimum:</label>
                <div class="slider-with-value">
                  <input
                    type="range"
                    id="x2-min"
                    min="-5"
                    max="0"
                    step="0.1"
                    value="-3"
                  />
                  <span class="value-display" id="x2-min-value">-3</span>
                </div>
              </div>
              <div class="slider-container">
                <label for="x2-max">x<sub>2</sub> maximum:</label>
                <div class="slider-with-value">
                  <input
                    type="range"
                    id="x2-max"
                    min="0"
                    max="5"
                    step="0.1"
                    value="3"
                  />
                  <span class="value-display" id="x2-max-value">3</span>
                </div>
              </div>
            </div>

            <div class="control-group">
              <h3>View Settings</h3>
              <div class="slider-container">
                <label for="resolution">Resolution:</label>
                <div class="slider-with-value">
                  <input
                    type="range"
                    id="resolution"
                    min="10"
                    max="100"
                    step="5"
                    value="40"
                  />
                  <span class="value-display" id="resolution-value">40</span>
                </div>
              </div>
              <div class="slider-container">
                <label for="samples">Sample functions:</label>
                <div class="slider-with-value">
                  <input
                    type="range"
                    id="samples"
                    min="0"
                    max="20"
                    step="1"
                    value="5"
                  />
                  <span class="value-display" id="samples-value">5</span>
                </div>
              </div>
              <div class="slider-container">
                <label for="point-x1">Test point x<sub>1</sub>:</label>
                <div class="slider-with-value">
                  <input
                    type="range"
                    id="point-x1"
                    min="-3"
                    max="3"
                    step="0.1"
                    value="1"
                  />
                  <span class="value-display" id="point-x1-value">1</span>
                </div>
              </div>
              <div class="slider-container">
                <label for="point-x2">Test point x<sub>2</sub>:</label>
                <div class="slider-with-value">
                  <input
                    type="range"
                    id="point-x2"
                    min="-3"
                    max="3"
                    step="0.1"
                    value="1"
                  />
                  <span class="value-display" id="point-x2-value">1</span>
                </div>
              </div>
            </div>
          </div>

          <div class="visualization">
            <div class="plot-container">
              <div class="plot-title">
                Mean Function: x<sub>1</sub><sup>2</sup> - 2x<sub>1</sub>x<sub
                  >2</sub
                >
                + cos(x<sub>2</sub>)
              </div>
              <div class="canvas-container" id="mean-plot">
                <canvas id="mean-canvas"></canvas>
                <div class="color-scale">
                  <div class="color-gradient"></div>
                </div>
                <div class="scale-labels">
                  <span class="scale-label" id="max-label">10</span>
                  <span class="scale-label">5</span>
                  <span class="scale-label">0</span>
                  <span class="scale-label">-5</span>
                  <span class="scale-label" id="min-label">-10</span>
                </div>
                <div class="tooltip" id="mean-tooltip"></div>
              </div>
            </div>

            <div class="plot-container">
              <div class="plot-title">
                Variance Function: cos(x<sub>1</sub><sup>2</sup> + x<sub>2</sub
                ><sup>2</sup>)
              </div>
              <div class="canvas-container" id="variance-plot">
                <canvas id="variance-canvas"></canvas>
                <div class="color-scale">
                  <div class="color-gradient"></div>
                </div>
                <div class="scale-labels">
                  <span class="scale-label" id="var-max-label">1</span>
                  <span class="scale-label">0.5</span>
                  <span class="scale-label">0</span>
                  <span class="scale-label">-0.5</span>
                  <span class="scale-label" id="var-min-label">-1</span>
                </div>
                <div class="tooltip" id="variance-tooltip"></div>
              </div>
            </div>
          </div>

          <div class="info-panel">
            <h3>Normal Distribution at Selected Point</h3>
            <p id="point-info">
              At x<sub>1</sub> = 1, x<sub>2</sub> = 1:
              <br />
              Mean = <span id="point-mean">0</span>
              <br />
              Variance = <span id="point-variance">0</span> (Standard Deviation
              = <span id="point-std">0</span>)
            </p>
            <div id="probability-plot"></div>
            <div class="sample-controls">
              <button id="generate-samples">Generate New Samples</button>
              <label for="sample-count">Samples:</label>
              <input
                type="number"
                id="sample-count"
                class="sample-count"
                min="1"
                max="50"
                value="10"
              />
            </div>
          </div>
        </div>

        <div class="tab-content" data-tab-content="about">
          <h3>What is Bayesian Optimization?</h3>
          <p>
            Bayesian Optimization is a sequential design strategy for global
            optimization of black-box functions that doesn't require
            derivatives. It's particularly useful when the objective function
            is:
          </p>
          <ul>
            <li>Expensive to evaluate</li>
            <li>Has no closed-form expression</li>
            <li>Doesn't have easily accessible derivatives</li>
          </ul>

          <h3>Key Components:</h3>
          <ol>
            <li>
              <strong>Surrogate Model</strong>: A probabilistic model (often a
              Gaussian Process) that approximates the objective function and
              provides uncertainty estimates.
            </li>
            <li>
              <strong>Acquisition Function</strong>: A function that guides the
              sampling strategy by balancing exploration and exploitation.
            </li>
          </ol>

          <h3>This Visualization:</h3>
          <p>The model shown here is a Gaussian Process where:</p>
          <ul>
            <li>
              The mean function (left plot) represents our best guess of the
              function value at each point.
            </li>
            <li>
              The variance function (right plot) represents our uncertainty
              about the function value.
            </li>
            <li>
              Sample realizations from this distribution represent possible
              objective functions that are consistent with our model.
            </li>
          </ul>
          <p>
            As you adjust the test point with the sliders, you can see how the
            normal distribution changes based on the input-dependent mean and
            variance.
          </p>
        </div>
      </div>
    </div>

    <script>
      // DOM Elements
      const x1MinSlider = document.getElementById("x1-min");
      const x1MaxSlider = document.getElementById("x1-max");
      const x2MinSlider = document.getElementById("x2-min");
      const x2MaxSlider = document.getElementById("x2-max");
      const resolutionSlider = document.getElementById("resolution");
      const samplesSlider = document.getElementById("samples");
      const pointX1Slider = document.getElementById("point-x1");
      const pointX2Slider = document.getElementById("point-x2");

      // Value displays
      const x1MinValue = document.getElementById("x1-min-value");
      const x1MaxValue = document.getElementById("x1-max-value");
      const x2MinValue = document.getElementById("x2-min-value");
      const x2MaxValue = document.getElementById("x2-max-value");
      const resolutionValue = document.getElementById("resolution-value");
      const samplesValue = document.getElementById("samples-value");
      const pointX1Value = document.getElementById("point-x1-value");
      const pointX2Value = document.getElementById("point-x2-value");

      // Point info - Changed from const to let to allow reassignment
      let pointMean = document.getElementById("point-mean");
      let pointVariance = document.getElementById("point-variance");
      let pointStd = document.getElementById("point-std");

      // Canvas elements
      const meanCanvas = document.getElementById("mean-canvas");
      const varianceCanvas = document.getElementById("variance-canvas");
      const meanCtx = meanCanvas.getContext("2d");
      const varianceCtx = varianceCanvas.getContext("2d");

      // Tooltip elements
      const meanTooltip = document.getElementById("mean-tooltip");
      const varianceTooltip = document.getElementById("variance-tooltip");

      // Scale labels
      const maxLabel = document.getElementById("max-label");
      const minLabel = document.getElementById("min-label");
      const varMaxLabel = document.getElementById("var-max-label");
      const varMinLabel = document.getElementById("var-min-label");

      // Sample controls
      const generateSamplesButton = document.getElementById("generate-samples");
      const sampleCountInput = document.getElementById("sample-count");

      // Tab functionality
      const tabs = document.querySelectorAll(".tab");
      const tabContents = document.querySelectorAll(".tab-content");

      tabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          tabs.forEach((t) => t.classList.remove("active"));
          tabContents.forEach((tc) => tc.classList.remove("active"));

          tab.classList.add("active");
          const activeTab = tab.getAttribute("data-tab");
          document
            .querySelector(`[data-tab-content="${activeTab}"]`)
            .classList.add("active");
        });
      });

      // State
      let x1Range = {
        min: parseFloat(x1MinSlider.value),
        max: parseFloat(x1MaxSlider.value),
      };
      let x2Range = {
        min: parseFloat(x2MinSlider.value),
        max: parseFloat(x2MaxSlider.value),
      };
      let resolution = parseInt(resolutionSlider.value);
      let numSamples = parseInt(samplesSlider.value);
      let pointX1 = parseFloat(pointX1Slider.value);
      let pointX2 = parseFloat(pointX2Slider.value);
      let meanData = [];
      let varianceData = [];
      let meanColorScale = { min: -10, max: 10 };
      let varianceColorScale = { min: -1, max: 1 };
      let realizations = [];

      // Event listeners for sliders
      x1MinSlider.addEventListener("input", function () {
        x1Range.min = parseFloat(this.value);
        x1MinValue.textContent = this.value;
        updatePointX1Bounds();
        calculateValues();
        drawPlots();
      });

      x1MaxSlider.addEventListener("input", function () {
        x1Range.max = parseFloat(this.value);
        x1MaxValue.textContent = this.value;
        updatePointX1Bounds();
        calculateValues();
        drawPlots();
      });

      x2MinSlider.addEventListener("input", function () {
        x2Range.min = parseFloat(this.value);
        x2MinValue.textContent = this.value;
        updatePointX2Bounds();
        calculateValues();
        drawPlots();
      });

      x2MaxSlider.addEventListener("input", function () {
        x2Range.max = parseFloat(this.value);
        x2MaxValue.textContent = this.value;
        updatePointX2Bounds();
        calculateValues();
        drawPlots();
      });

      resolutionSlider.addEventListener("input", function () {
        resolution = parseInt(this.value);
        resolutionValue.textContent = this.value;
        calculateValues();
        drawPlots();
      });

      samplesSlider.addEventListener("input", function () {
        numSamples = parseInt(this.value);
        samplesValue.textContent = this.value;
        generateRealizations();
        drawPlots();
      });

      pointX1Slider.addEventListener("input", function () {
        pointX1 = parseFloat(this.value);
        pointX1Value.textContent = this.value;
        updatePointInfo();
        drawPlots();
        drawProbabilityPlot();
      });

      pointX2Slider.addEventListener("input", function () {
        pointX2 = parseFloat(this.value);
        pointX2Value.textContent = this.value;
        updatePointInfo();
        drawPlots();
        drawProbabilityPlot();
      });

      generateSamplesButton.addEventListener("click", function () {
        const count = parseInt(sampleCountInput.value);
        if (count > 0 && count <= 50) {
          numSamples = count;
          samplesSlider.value = Math.min(count, 20); // Update slider if within its range
          samplesValue.textContent = samplesSlider.value;

          // Regenerate samples with animation feedback
          this.disabled = true;
          this.textContent = "Generating...";

          // Use setTimeout to give visual feedback and ensure UI updates
          setTimeout(() => {
            // Force regeneration of all samples
            generateRealizations();
            drawPlots();
            drawProbabilityPlot();

            // Restore button
            this.disabled = false;
            this.textContent = "Generate New Samples";

            // Flash animation to indicate new samples were generated
            document.querySelectorAll(".realization-point").forEach((point) => {
              point.style.animation = "pulse 0.5s";
            });
          }, 100);
        }
      });

      // Model functions
      function meanFunction(x1, x2) {
        return x1 * x1 - 2 * x1 * x2 + Math.cos(x2);
      }

      function varianceFunction(x1, x2) {
        return Math.cos(x1 * x1 + x2 * x2);
      }

      // Normal distribution random number generator using Box-Muller transform
      function randomNormal(mean, variance) {
        if (variance < 0) variance = Math.abs(variance); // Ensure variance is positive
        let u = 0,
          v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        return mean + Math.sqrt(variance) * z;
      }

      // Update slider bounds for the test point
      function updatePointX1Bounds() {
        pointX1Slider.min = x1Range.min;
        pointX1Slider.max = x1Range.max;
        pointX1 = Math.max(x1Range.min, Math.min(x1Range.max, pointX1));
        pointX1Slider.value = pointX1;
        pointX1Value.textContent = pointX1.toFixed(1);
      }

      function updatePointX2Bounds() {
        pointX2Slider.min = x2Range.min;
        pointX2Slider.max = x2Range.max;
        pointX2 = Math.max(x2Range.min, Math.min(x2Range.max, pointX2));
        pointX2Slider.value = pointX2;
        pointX2Value.textContent = pointX2.toFixed(1);
      }

      // Calculate values for the plots
      function calculateValues() {
        meanData = [];
        varianceData = [];

        const dx1 = (x1Range.max - x1Range.min) / (resolution - 1);
        const dx2 = (x2Range.max - x2Range.min) / (resolution - 1);

        let minMean = Infinity;
        let maxMean = -Infinity;
        let minVariance = Infinity;
        let maxVariance = -Infinity;

        for (let i = 0; i < resolution; i++) {
          const row = [];
          const varRow = [];
          const x1 = x1Range.min + i * dx1;

          for (let j = 0; j < resolution; j++) {
            const x2 = x2Range.min + j * dx2;

            const mean = meanFunction(x1, x2);
            const variance = varianceFunction(x1, x2);

            row.push({ x1, x2, value: mean });
            varRow.push({ x1, x2, value: variance });

            minMean = Math.min(minMean, mean);
            maxMean = Math.max(maxMean, mean);
            minVariance = Math.min(minVariance, variance);
            maxVariance = Math.max(maxVariance, variance);
          }

          meanData.push(row);
          varianceData.push(varRow);
        }

        // Update color scales if values are outside current range
        if (minMean < meanColorScale.min || maxMean > meanColorScale.max) {
          const padding = (maxMean - minMean) * 0.1;
          meanColorScale = {
            min: Math.floor(minMean - padding),
            max: Math.ceil(maxMean + padding),
          };
          maxLabel.textContent = meanColorScale.max;
          minLabel.textContent = meanColorScale.min;
        }

        if (
          minVariance < varianceColorScale.min ||
          maxVariance > varianceColorScale.max
        ) {
          const padding = (maxVariance - minVariance) * 0.1;
          varianceColorScale = {
            min: Math.floor((minVariance - padding) * 10) / 10,
            max: Math.ceil((maxVariance + padding) * 10) / 10,
          };
          varMaxLabel.textContent = varianceColorScale.max;
          varMinLabel.textContent = varianceColorScale.min;
        }

        generateRealizations();
        updatePointInfo();
      }

      // Generate random realizations of the function
      function generateRealizations() {
        console.log("Generating new realizations...");
        realizations = [];

        for (let s = 0; s < numSamples; s++) {
          const realization = [];

          for (let i = 0; i < resolution; i++) {
            const row = [];

            for (let j = 0; j < resolution; j++) {
              const mean = meanData[i][j].value;
              const variance = varianceData[i][j].value;
              const value = randomNormal(mean, Math.max(0, variance)); // Ensure variance is non-negative

              row.push(value);
            }

            realization.push(row);
          }

          realizations.push(realization);
        }
        console.log(`Generated ${numSamples} realizations`);
      }

      // Update information about the selected point
      function updatePointInfo() {
        const mean = meanFunction(pointX1, pointX2);
        const variance = varianceFunction(pointX1, pointX2);
        const stdDev = Math.sqrt(Math.abs(variance)); // Absolute value to handle negative variance

        document.getElementById(
          "point-info"
        ).innerHTML = `At x<sub>1</sub> = ${pointX1.toFixed(
          2
        )}, x<sub>2</sub> = ${pointX2.toFixed(2)}:<br>
        Mean = <span id="point-mean">${mean.toFixed(3)}</span><br>
        Variance = <span id="point-variance">${variance.toFixed(
          3
        )}</span> (Standard Deviation = <span id="point-std">${stdDev.toFixed(
          3
        )}</span>)`;

        // Update references after the HTML has been changed
        pointMean = document.getElementById("point-mean");
        pointVariance = document.getElementById("point-variance");
        pointStd = document.getElementById("point-std");

        drawProbabilityPlot();
      }

      // Draw a normal distribution curve
      function drawProbabilityPlot() {
        const container = document.getElementById("probability-plot");
        container.innerHTML = "";

        const width = container.clientWidth;
        const height = container.clientHeight;

        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);
        container.appendChild(svg);

        const mean = meanFunction(pointX1, pointX2);
        const variance = Math.max(0.01, varianceFunction(pointX1, pointX2)); // Ensure positive variance
        const stdDev = Math.sqrt(variance);

        // X range for the normal distribution plot
        const plotRange = 4 * stdDev;
        const xMin = mean - plotRange;
        const xMax = mean + plotRange;

        // Function to calculate normal PDF
        function normalPDF(x, mean, stdDev) {
          const a = 1 / (stdDev * Math.sqrt(2 * Math.PI));
          const b = -Math.pow(x - mean, 2) / (2 * variance);
          return a * Math.exp(b);
        }

        // Calculate points for the curve
        const points = [];
        const numPoints = 100;
        let maxPdf = 0;

        for (let i = 0; i < numPoints; i++) {
          const x = xMin + (i / (numPoints - 1)) * (xMax - xMin);
          const y = normalPDF(x, mean, stdDev);
          maxPdf = Math.max(maxPdf, y);
          points.push({ x, y });
        }

        // Create path
        const pathData = points
          .map((p, i) => {
            const x = ((p.x - xMin) / (xMax - xMin)) * width;
            const y = height - (p.y / maxPdf) * (height - 20);
            return (i === 0 ? "M" : "L") + x + "," + y;
          })
          .join(" ");

        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        path.setAttribute("d", pathData);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "#3b82f6");
        path.setAttribute("stroke-width", "2");
        svg.appendChild(path);

        // Add area under the curve
        const areaData =
          pathData + " L" + width + "," + height + " L0," + height + " Z";
        const area = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        area.setAttribute("d", areaData);
        area.setAttribute("fill", "rgba(59, 130, 246, 0.2)");
        area.setAttribute("stroke", "none");
        svg.insertBefore(area, path);

        // Add axes
        const xAxis = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line"
        );
        xAxis.setAttribute("x1", 0);
        xAxis.setAttribute("y1", height - 1);
        xAxis.setAttribute("x2", width);
        xAxis.setAttribute("y2", height - 1);
        xAxis.setAttribute("stroke", "#64748b");
        xAxis.setAttribute("stroke-width", "1");
        svg.appendChild(xAxis);

        // Add mean line
        const meanX = ((mean - xMin) / (xMax - xMin)) * width;
        const meanLine = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line"
        );
        meanLine.setAttribute("x1", meanX);
        meanLine.setAttribute("y1", 0);
        meanLine.setAttribute("x2", meanX);
        meanLine.setAttribute("y2", height);
        meanLine.setAttribute("stroke", "#ef4444");
        meanLine.setAttribute("stroke-width", "2");
        meanLine.setAttribute("stroke-dasharray", "4,4");
        svg.appendChild(meanLine);

        // Add mean label
        const meanLabel = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "text"
        );
        meanLabel.setAttribute("x", meanX);
        meanLabel.setAttribute("y", height - 5);
        meanLabel.setAttribute("text-anchor", "middle");
        meanLabel.setAttribute("fill", "#ef4444");
        meanLabel.setAttribute("font-size", "10px");
        meanLabel.textContent = "μ";
        svg.appendChild(meanLabel);

        // Add μ±σ lines
        const sigmaPlus = ((mean + stdDev - xMin) / (xMax - xMin)) * width;
        const sigmaMinus = ((mean - stdDev - xMin) / (xMax - xMin)) * width;

        const sigmaPlus1 = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line"
        );
        sigmaPlus1.setAttribute("x1", sigmaPlus);
        sigmaPlus1.setAttribute("y1", 10);
        sigmaPlus1.setAttribute("x2", sigmaPlus);
        sigmaPlus1.setAttribute("y2", height - 10);
        sigmaPlus1.setAttribute("stroke", "#22c55e");
        sigmaPlus1.setAttribute("stroke-width", "1");
        sigmaPlus1.setAttribute("stroke-dasharray", "2,2");
        svg.appendChild(sigmaPlus1);

        const sigmaMinus1 = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line"
        );
        sigmaMinus1.setAttribute("x1", sigmaMinus);
        sigmaMinus1.setAttribute("y1", 10);
        sigmaMinus1.setAttribute("x2", sigmaMinus);
        sigmaMinus1.setAttribute("y2", height - 10);
        sigmaMinus1.setAttribute("stroke", "#22c55e");
        sigmaMinus1.setAttribute("stroke-width", "1");
        sigmaMinus1.setAttribute("stroke-dasharray", "2,2");
        svg.appendChild(sigmaMinus1);

        // Generate random samples from this distribution
        const sampleCount = parseInt(sampleCountInput.value);
        const samples = [];

        for (let i = 0; i < sampleCount; i++) {
          samples.push(randomNormal(mean, variance));
        }

        // Draw samples as dots
        samples.forEach((sample) => {
          const x = ((sample - xMin) / (xMax - xMin)) * width;
          if (x >= 0 && x <= width) {
            const dot = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle"
            );
            dot.setAttribute("cx", x);
            dot.setAttribute("cy", height - 15);
            dot.setAttribute("r", 3);
            dot.setAttribute("fill", "#ef4444");
            svg.appendChild(dot);
          }
        });
      }

      // Color mapping function
      function getColor(value, min, max) {
        const normalizedValue = (value - min) / (max - min);
        const hue = (1 - normalizedValue) * 240; // 240 (blue) to 0 (red)
        return `hsl(${hue}, 100%, 50%)`;
      }

      // Draw heatmaps and samples
      function drawPlots() {
        resizeCanvases();

        drawHeatmap(meanCanvas, meanCtx, meanData, meanColorScale);
        drawHeatmap(
          varianceCanvas,
          varianceCtx,
          varianceData,
          varianceColorScale
        );

        // Draw realizations (samples)
        drawRealizations();

        // Draw test point marker
        drawTestPoint();
      }

      // Resize canvases to match container sizes
      function resizeCanvases() {
        const meanContainer = document.getElementById("mean-plot");
        const varianceContainer = document.getElementById("variance-plot");

        meanCanvas.width = meanContainer.clientWidth;
        meanCanvas.height = meanContainer.clientHeight;

        varianceCanvas.width = varianceContainer.clientWidth;
        varianceCanvas.height = varianceContainer.clientHeight;
      }

      // Draw heatmap on canvas
      function drawHeatmap(canvas, ctx, data, colorScale) {
        const width = canvas.width;
        const height = canvas.height;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        const dx = width / resolution;
        const dy = height / resolution;

        for (let i = 0; i < resolution; i++) {
          for (let j = 0; j < resolution; j++) {
            const x = j * dx;
            const y = i * dy;
            const value = data[i][j].value;

            ctx.fillStyle = getColor(value, colorScale.min, colorScale.max);
            ctx.fillRect(x, y, dx + 1, dy + 1); // +1 to avoid gaps
          }
        }

        // Draw grid
        ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
        ctx.lineWidth = 0.5;

        for (let i = 0; i <= resolution; i++) {
          const x = i * dx;
          const y = i * dy;

          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        // Draw axes
        const x1Zero = Math.max(
          0,
          Math.min(
            width,
            ((0 - x1Range.min) / (x1Range.max - x1Range.min)) * width
          )
        );
        const x2Zero = Math.max(
          0,
          Math.min(
            height,
            height - ((0 - x2Range.min) / (x2Range.max - x2Range.min)) * height
          )
        );

        ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
        ctx.lineWidth = 1.5;

        // x1 axis (horizontal)
        ctx.beginPath();
        ctx.moveTo(0, x2Zero);
        ctx.lineTo(width, x2Zero);
        ctx.stroke();

        // x2 axis (vertical)
        ctx.beginPath();
        ctx.moveTo(x1Zero, 0);
        ctx.lineTo(x1Zero, height);
        ctx.stroke();

        // Draw labels
        ctx.fillStyle = "black";
        ctx.font = "12px Arial";

        // x1 label
        ctx.fillText("x₁", width - 15, x2Zero - 5);

        // x2 label
        ctx.fillText("x₂", x1Zero + 5, 15);

        // Draw tick marks and values
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.font = "10px Arial";

        // x1 ticks
        const x1Ticks = 5;
        for (let i = 0; i <= x1Ticks; i++) {
          const x = (i / x1Ticks) * width;
          const value =
            x1Range.min + (i / x1Ticks) * (x1Range.max - x1Range.min);

          ctx.beginPath();
          ctx.moveTo(x, x2Zero - 3);
          ctx.lineTo(x, x2Zero + 3);
          ctx.stroke();

          ctx.fillText(value.toFixed(1), x - 10, x2Zero + 15);
        }

        // x2 ticks
        const x2Ticks = 5;
        for (let i = 0; i <= x2Ticks; i++) {
          const y = (i / x2Ticks) * height;
          const value =
            x2Range.max - (i / x2Ticks) * (x2Range.max - x2Range.min);

          ctx.beginPath();
          ctx.moveTo(x1Zero - 3, y);
          ctx.lineTo(x1Zero + 3, y);
          ctx.stroke();

          ctx.fillText(value.toFixed(1), x1Zero - 25, y + 5);
        }
      }

      // Draw random function realizations as contour lines
      function drawRealizations() {
        if (numSamples <= 0) return;

        const meanContainer = document.getElementById("mean-plot");
        const width = meanContainer.clientWidth;
        const height = meanContainer.clientHeight;

        const dx = width / (resolution - 1);
        const dy = height / (resolution - 1);

        // Remove existing realization points
        const existingPoints = document.querySelectorAll(".realization-point");
        existingPoints.forEach((point) => point.remove());

        // Generate and show realization points
        for (let s = 0; s < numSamples; s++) {
          // Pick a random color for this realization
          const hue = Math.random() * 360;

          for (let i = 0; i < resolution; i++) {
            for (let j = 0; j < resolution; j++) {
              // Only show points with 5% probability to avoid clutter
              if (Math.random() < 0.05) {
                const x = j * dx;
                const y = i * dy;

                const point = document.createElement("div");
                point.className = "realization-point";
                point.style.left = x + "px";
                point.style.top = y + "px";
                point.style.backgroundColor = `hsla(${hue}, 80%, 50%, 0.7)`;

                meanContainer.appendChild(point);
              }
            }
          }
        }
      }

      // Draw marker for test point
      function drawTestPoint() {
        const meanContainer = document.getElementById("mean-plot");
        const varianceContainer = document.getElementById("variance-plot");

        const width = meanContainer.clientWidth;
        const height = meanContainer.clientHeight;

        // Calculate pixel coordinates
        const x =
          ((pointX1 - x1Range.min) / (x1Range.max - x1Range.min)) * width;
        const y =
          ((x2Range.max - pointX2) / (x2Range.max - x2Range.min)) * height;

        // Draw on mean plot
        meanCtx.fillStyle = "white";
        meanCtx.strokeStyle = "black";
        meanCtx.lineWidth = 2;

        meanCtx.beginPath();
        meanCtx.arc(x, y, 6, 0, 2 * Math.PI);
        meanCtx.fill();
        meanCtx.stroke();

        meanCtx.fillStyle = "red";
        meanCtx.beginPath();
        meanCtx.arc(x, y, 4, 0, 2 * Math.PI);
        meanCtx.fill();

        // Draw on variance plot
        varianceCtx.fillStyle = "white";
        varianceCtx.strokeStyle = "black";
        varianceCtx.lineWidth = 2;

        varianceCtx.beginPath();
        varianceCtx.arc(x, y, 6, 0, 2 * Math.PI);
        varianceCtx.fill();
        varianceCtx.stroke();

        varianceCtx.fillStyle = "red";
        varianceCtx.beginPath();
        varianceCtx.arc(x, y, 4, 0, 2 * Math.PI);
        varianceCtx.fill();
      }

      // Setup tooltips
      function setupTooltips() {
        const meanContainer = document.getElementById("mean-plot");
        const varianceContainer = document.getElementById("variance-plot");

        meanContainer.addEventListener("mousemove", function (event) {
          const rect = meanCanvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          showTooltip(meanContainer, meanTooltip, x, y, meanData);
        });

        meanContainer.addEventListener("mouseout", function () {
          meanTooltip.style.display = "none";
        });

        varianceContainer.addEventListener("mousemove", function (event) {
          const rect = varianceCanvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          showTooltip(varianceContainer, varianceTooltip, x, y, varianceData);
        });

        varianceContainer.addEventListener("mouseout", function () {
          varianceTooltip.style.display = "none";
        });
      }

      // Show tooltip with values
      function showTooltip(container, tooltip, x, y, data) {
        const width = container.clientWidth;
        const height = container.clientHeight;

        // Calculate data coordinates
        const x1Percent = x / width;
        const x2Percent = 1 - y / height;

        const x1 = x1Range.min + x1Percent * (x1Range.max - x1Range.min);
        const x2 = x2Range.min + x2Percent * (x2Range.max - x2Range.min);

        // Find closest data point
        const i = Math.min(resolution - 1, Math.floor(x2Percent * resolution));
        const j = Math.min(resolution - 1, Math.floor(x1Percent * resolution));

        if (i >= 0 && i < data.length && j >= 0 && j < data[i].length) {
          const value = data[i][j].value;

          tooltip.innerHTML = `
          x<sub>1</sub> = ${x1.toFixed(2)}<br>
          x<sub>2</sub> = ${x2.toFixed(2)}<br>
          value = ${value.toFixed(3)}
        `;

          tooltip.style.display = "block";
          tooltip.style.left = x + 10 + "px";
          tooltip.style.top = y + 10 + "px";
        }
      }

      // Initial setup
      function initialize() {
        // Set initial values
        x1MinValue.textContent = x1Range.min;
        x1MaxValue.textContent = x1Range.max;
        x2MinValue.textContent = x2Range.min;
        x2MaxValue.textContent = x2Range.max;
        resolutionValue.textContent = resolution;
        samplesValue.textContent = numSamples;
        pointX1Value.textContent = pointX1;
        pointX2Value.textContent = pointX2;

        // Calculate values
        calculateValues();

        // Draw plots
        window.addEventListener("resize", function () {
          drawPlots();
        });

        drawPlots();
        drawProbabilityPlot();

        // Setup tooltips
        setupTooltips();
      }

      // Start the application
      initialize();

      // Add CSS for loading spinner
      const spinnerStyle = document.createElement("style");
      spinnerStyle.textContent = `
        .loading {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(255, 255, 255, 0.8);
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          z-index: 1000;
        }
        
        .loading-spinner {
          width: 40px;
          height: 40px;
          border: 5px solid rgba(59, 130, 246, 0.3);
          border-radius: 50%;
          border-top-color: #3b82f6;
          animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
          to {
            transform: rotate(360deg);
          }
        }
      `;
      document.head.appendChild(spinnerStyle);

      // Listen for messages from the parent page
      window.addEventListener("message", function (event) {
        // Make sure the message is from a trusted source
        // In production, you'd want to check event.origin

        if (event.data && event.data.action) {
          switch (event.data.action) {
            case "reset":
              // Reset all sliders to default values
              x1MinSlider.value = "-3";
              x1MaxSlider.value = "3";
              x2MinSlider.value = "-3";
              x2MaxSlider.value = "3";
              resolutionSlider.value = "40";
              samplesSlider.value = "5";
              pointX1Slider.value = "1";
              pointX2Slider.value = "1";

              // Update internal state variables
              x1Range = { min: -3, max: 3 };
              x2Range = { min: -3, max: 3 };
              resolution = 40;
              numSamples = 5;
              pointX1 = 1;
              pointX2 = 1;

              // Update display values
              x1MinValue.textContent = x1Range.min;
              x1MaxValue.textContent = x1Range.max;
              x2MinValue.textContent = x2Range.min;
              x2MaxValue.textContent = x2Range.max;
              resolutionValue.textContent = resolution;
              samplesValue.textContent = numSamples;
              pointX1Value.textContent = pointX1;
              pointX2Value.textContent = pointX2;

              // Recalculate and redraw
              calculateValues();
              drawPlots();
              drawProbabilityPlot();
              break;

            case "findOptimal":
              // Find the optimal balance between good mean and low variance

              // Show loading indicator
              const loadingEl = document.createElement("div");
              loadingEl.className = "loading";
              loadingEl.innerHTML =
                '<div class="loading-spinner"></div><div style="margin-top: 10px">Finding optimal point...</div>';
              document.body.appendChild(loadingEl);

              // Use setTimeout to ensure the UI updates
              setTimeout(() => {
                // In a real implementation, this would be a more sophisticated algorithm
                // Here we'll search through a grid of points to find a good balance

                // Define grid search parameters
                const searchResolution = 20;
                const searchMinX1 = Math.max(-2, x1Range.min);
                const searchMaxX1 = Math.min(2, x1Range.max);
                const searchMinX2 = Math.max(-2, x2Range.min);
                const searchMaxX2 = Math.min(2, x2Range.max);

                let bestPoint = { x1: 0, x2: 0, score: -Infinity };

                // Grid search for balance of good mean and low variance
                for (let i = 0; i < searchResolution; i++) {
                  for (let j = 0; j < searchResolution; j++) {
                    const x1 =
                      searchMinX1 +
                      (searchMaxX1 - searchMinX1) *
                        (i / (searchResolution - 1));
                    const x2 =
                      searchMinX2 +
                      (searchMaxX2 - searchMinX2) *
                        (j / (searchResolution - 1));

                    // Calculate mean and variance at this point
                    const mean = meanFunction(x1, x2);
                    const variance = varianceFunction(x1, x2);

                    // Our score function balances:
                    // 1. Higher (better) mean values
                    // 2. Lower variance values (more certainty)
                    // 3. With more weight on low variance (key insight from the case studies)

                    // Normalize mean to a 0-1 scale (approximately)
                    const normalizedMean = (mean + 5) / 10; // Assuming means are roughly in range [-5, 5]

                    // Normalize variance to a 0-1 scale with inversion (lower is better)
                    const normalizedVariance = (-variance + 1) / 2; // Assuming variance is roughly in range [-1, 1]

                    // Score function with stronger weight (2x) on variance
                    const score = normalizedMean + 2 * normalizedVariance;

                    if (score > bestPoint.score) {
                      bestPoint = { x1, x2, score, mean, variance };
                    }
                  }
                }

                // Set the sliders to the optimal point
                pointX1 = bestPoint.x1;
                pointX2 = bestPoint.x2;
                pointX1Slider.value = pointX1;
                pointX2Slider.value = pointX2;
                pointX1Value.textContent = pointX1.toFixed(2);
                pointX2Value.textContent = pointX2.toFixed(2);

                // Update the visualization
                updatePointInfo();
                drawPlots();
                drawProbabilityPlot();

                // Remove loading indicator
                document.body.removeChild(loadingEl);

                // Create a temporary notification
                const notification = document.createElement("div");
                notification.style.position = "fixed";
                notification.style.top = "20px";
                notification.style.left = "50%";
                notification.style.transform = "translateX(-50%)";
                notification.style.padding = "10px 20px";
                notification.style.background = "#10b981";
                notification.style.color = "white";
                notification.style.borderRadius = "6px";
                notification.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                notification.style.zIndex = "1000";
                notification.style.transition = "opacity 0.5s ease";
                notification.innerHTML = `
                  <strong>Optimal point found!</strong><br>
                  x₁ = ${bestPoint.x1.toFixed(2)}, x₂ = ${bestPoint.x2.toFixed(2)}<br>
                  Mean = ${bestPoint.mean.toFixed(2)}, Variance = ${bestPoint.variance.toFixed(2)}
                `;
                document.body.appendChild(notification);

                // Remove notification after a few seconds
                setTimeout(() => {
                  notification.style.opacity = "0";
                  setTimeout(() => {
                    document.body.removeChild(notification);
                  }, 500);
                }, 5000);
              }, 100);
              break;
          }
        }
      });

      // Send height information to parent
      function updateParentAboutHeight() {
        const height = document.body.scrollHeight;
        window.parent.postMessage(
          {
            type: "resize-iframe",
            height: height,
          },
          "*"
        );
      }

      // Update on load and whenever content changes
      window.addEventListener("load", updateParentAboutHeight);
      window.addEventListener("resize", updateParentAboutHeight);
    </script>
  </body>
</html>